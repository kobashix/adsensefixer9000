from __future__ import annotations

import re
from typing import List

from bs4 import BeautifulSoup

from gpvb.models import Finding, FindingCategory, PageResult, Severity

from .context import ProgramPolicyContext


MALWARE_POLICY_LINKS = [
    "https://support.google.com/adsense/answer/1346295",
    "https://support.google.com/webmasters/answer/6350487",
]

DOWNLOAD_EXTENSIONS = (".exe", ".apk", ".zip", ".msi")
SHORTENER_DOMAINS = ("bit.ly", "tinyurl.com", "t.co", "goo.gl", "ow.ly", "is.gd")


def _detect_forced_download(html: str) -> bool:
    return bool(
        re.search(r"window\.location\s*=\s*['\"][^'\"]+\.(exe|apk|zip|msi)", html, re.IGNORECASE)
        or re.search(r"<meta[^>]+http-equiv=['\"]?refresh[^>]+url=[^'\"]+\.(exe|apk|zip|msi)", html, re.IGNORECASE)
    )


def detect_malware_risk(page: PageResult, context: ProgramPolicyContext) -> List[Finding]:
    findings: List[Finding] = []
    soup = BeautifulSoup(page.html, "lxml")
    download_links = []
    shorteners = []
    for link in soup.find_all("a", href=True):
        href = link["href"].lower()
        if href.endswith(DOWNLOAD_EXTENSIONS):
            download_links.append(href)
        if any(domain in href for domain in SHORTENER_DOMAINS):
            shorteners.append(href)

    forced_download = _detect_forced_download(page.html)
    if forced_download:
        findings.append(
            Finding(
                detector="malware_forced_download",
                severity=Severity.critical,
                category=FindingCategory.program_policy,
                confidence=0.84,
                message="Forced download behavior detected.",
                remediation=[
                    "Remove auto-downloads or redirects to executable files.",
                    "Require explicit user action before initiating downloads.",
                ],
                policy_links=MALWARE_POLICY_LINKS,
                evidence={"download_links": download_links},
            )
        )

    misleading_download = False
    for ad in page.ad_elements:
        for block in context.text_blocks:
            if abs(block.y - ad.y) <= 200 and re.search(r"download", block.text, re.IGNORECASE):
                misleading_download = True
                break
        if misleading_download:
            break

    if misleading_download:
        findings.append(
            Finding(
                detector="malware_misleading_download_ui",
                severity=Severity.high,
                category=FindingCategory.program_policy,
                confidence=0.68,
                message="Download language appears adjacent to ad placements.",
                remediation=[
                    "Move download calls-to-action away from ad units.",
                    "Ensure download buttons are clearly separated from ads.",
                ],
                policy_links=MALWARE_POLICY_LINKS,
                evidence={"download_links": download_links},
            )
        )

    if shorteners and not forced_download:
        findings.append(
            Finding(
                detector="malware_shortener_usage",
                severity=Severity.medium,
                category=FindingCategory.program_policy,
                confidence=0.45,
                message="Download or outbound links use URL shorteners.",
                remediation=[
                    "Avoid URL shorteners for download links.",
                    "Use transparent, direct links to known destinations.",
                ],
                policy_links=MALWARE_POLICY_LINKS,
                evidence={"shortener_links": shorteners},
            )
        )
    return findings
